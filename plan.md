# План рефакторинга навигации в TUI

Этот документ описывает план по рефакторингу системы навигации в TUI для повышения модульности, читаемости и упрощения дальнейшей разработки.

## Текущие проблемы

1.  **Разбросанная логика:** Глобальные обработчики клавиш (например, `q`, `esc`) находятся в `tui/tui.go`, а локальные (например, `e` для редактирования квестов) — в файлах, специфичных для каждого состояния (`tui/quests.go`). Это усложняет понимание полной логики управления для одного экрана.
2.  **Жестко закодированная навигация "Назад":** Логика возврата на предыдущий экран реализована через большой `switch` в `tui/tui.go`. Это делает добавление новых состояний с нестандартной логикой возврата сложным и подверженны�� ошибкам.
3.  **Неявные правила навигации:** Горячие клавиши и переходы между состояниями "зашиты" в коде, отсутствует единое место для их описания.

## План реализации

### Шаг 1: Внедрение Стека состояний (State Stack)

**Цель:** Сделать навигацию "назад" универсальной и не зависящей от текущего состояния.

**Действия:**

1.  **Добавить стек в модель:** В `tui/tui.go`, в структуру `Model`, добавить поле `stateStack []state`.
2.  **Создать методы управления состоянием:**
    *   `pushState(newState state)`: Вместо прямого присваивания `m.state = newState`, этот метод будет добавлять *текущее* состояние в `stateStack`, а затем устанавливать новое.
    *   `popState()`: Этот метод будет извлекать последнее состояние из стека и делать его текущим. Если стек пуст, он будет инициировать выход из приложения.
3.  **Рефакторинг об��аботчика "Назад":** Заменить `switch` для клавиш `q` и `esc` в `tui/tui.go` на один вызов `m.popState()`.

### Шаг 2: Централизация и модульность обработчиков состояний

**Цель:** Сделать каждое состояние TUI самодостаточным модулем.

**Действия:**

1.  **Перенести логику:** Переместить все обработчики клавиш, специфичные для конкретных состояний, из `tui/tui.go` в соответствующие файлы (`tui/quests.go`, `tui/homepage.go` и т.д.).
2.  **Использовать стек:** Заменить все прямые присваивания `m.state = ...` на вызовы `m.pushState(...)`.

### Шаг 3: Создание Карты клавиш (Keymap) для навигационных подсказок

**Цель:** Декларативно описывать навигационные подсказки и отвязать их от императивного кода.

**Действия:**

1.  **Создать файл `tui/keymap.go`:** Этот файл будет содержать всю логику, связанную с картой клавиш.
2.  **Определить структуры:**
    *   `KeyBinding { Key string; Description string; }`
3.  **Создать карту:**
    *   `KeyMap map[state][]KeyBinding`: Глобальная карта, которая сопоставляет каждое состояние со списком его горячих клавиш и их описаний.
4.  **Создать функцию рендеринга:**
    *   `func (m *Model) getNavigationText() string`: Эта функция будет находить в `KeyMap` подсказки для текущего состояния (`m.state`) и форматировать их в строку для отображения.
5.  **Интегрировать в `View()`:** Заменить большой `switch` для `navText` в `tui/tui.go` на вызов `m.getNavigationText()`.

Этот план позволит создать гибкую, предсказуемую и легко расширяемую систему навигации.

---

## Принципы дизайна древа навыков (из статьи GDKeys)

1.  **Значимый выбор:** Дерево должно заставлять игрока делать важные выборы, влияющие на стиль игры, а не просто собирать все подряд.
2.  **Самовыражение:** Навыки должны позволять создавать уникальных персонажей и специализации (Маг огня, Воин-танк и т.д.).
3.  **Качество навыков > Количество:**
    *   **Избегать "плохих" навыков:** Незначительные пассивные бонусы (+5% к чему-либо) — скучны.
    *   **Предпочитать "хорошие" навыки:** Навыки, которые добавляют новые действия и механики (например, "создать", "бросить", "исцелить"), гораздо интереснее. Они должны содержать глагол действия.
4.  **Сбалансированный размер:** Дерево не должно быть слишком большим, чтобы не вызывать "паралич выбора". Оно должно предлагать четкие пути развития.
5.  **Возможность перераспределения (Respec):** Стоит предусмотреть возможность сброса навыков, но она не должна быть слишком дешевой, чтобы выбор оставался значимым.
6.  **Полнота заполнения:** В идеале, игрок не должен иметь возможность изучить абсолютно все навыки к концу игры, чтобы его выбор специализации имел вес.
